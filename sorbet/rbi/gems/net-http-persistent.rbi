# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/net-http-persistent/all/net-http-persistent.rbi
#
# net-http-persistent-3.0.0
class Net::HTTP::Persistent::Connection
  def finish; end
  def http; end
  def http=(arg0); end
  def initialize(http_class, http_args, ssl_generation); end
  def last_use; end
  def last_use=(arg0); end
  def requests; end
  def requests=(arg0); end
  def reset; end
  def ressl(ssl_generation); end
  def ssl_generation; end
  def ssl_generation=(arg0); end
end
class Net::HTTP::Persistent::TimedStackMulti < ConnectionPool::TimedStack
  def connection_stored?(options = nil); end
  def empty?; end
  def fetch_connection(options = nil); end
  def initialize(size = nil, &block); end
  def length; end
  def lru_update(connection_args); end
  def shutdown_connections; end
  def store_connection(obj, options = nil); end
  def try_create(options = nil); end
end
class Net::HTTP::Persistent::Pool < ConnectionPool
  def available; end
  def checkin(net_http_args); end
  def checkout(net_http_args); end
  def initialize(options = nil, &block); end
  def key; end
end
class Net::HTTP::Persistent
  def ca_file; end
  def ca_file=(file); end
  def ca_path; end
  def ca_path=(path); end
  def can_retry?(req); end
  def cert; end
  def cert=(certificate); end
  def cert_store; end
  def cert_store=(store); end
  def certificate; end
  def certificate=(certificate); end
  def ciphers; end
  def ciphers=(ciphers); end
  def connection_for(uri); end
  def debug_output; end
  def debug_output=(arg0); end
  def error_message(connection); end
  def escape(str); end
  def expired?(connection); end
  def finish(connection); end
  def generation; end
  def headers; end
  def http_version(uri); end
  def http_versions; end
  def idempotent?(req); end
  def idle_timeout; end
  def idle_timeout=(arg0); end
  def initialize(name: nil, proxy: nil, pool_size: nil); end
  def keep_alive; end
  def keep_alive=(arg0); end
  def key; end
  def key=(key); end
  def max_requests; end
  def max_requests=(arg0); end
  def name; end
  def no_proxy; end
  def normalize_uri(uri); end
  def open_timeout; end
  def open_timeout=(arg0); end
  def override_headers; end
  def pipeline(uri, requests, &block); end
  def pool; end
  def private_key; end
  def private_key=(key); end
  def proxy=(proxy); end
  def proxy_bypass?(host, port); end
  def proxy_from_env; end
  def proxy_uri; end
  def read_timeout; end
  def read_timeout=(arg0); end
  def reconnect; end
  def reconnect_ssl; end
  def request(uri, req = nil, &block); end
  def request_failed(exception, req, connection); end
  def request_setup(req_or_uri); end
  def reset(connection); end
  def retry_change_requests; end
  def retry_change_requests=(arg0); end
  def reuse_ssl_sessions; end
  def reuse_ssl_sessions=(arg0); end
  def self.detect_idle_timeout(uri, max = nil); end
  def shutdown; end
  def socket_options; end
  def ssl(connection); end
  def ssl_generation; end
  def ssl_timeout; end
  def ssl_timeout=(ssl_timeout); end
  def ssl_version; end
  def ssl_version=(ssl_version); end
  def start(http); end
  def timeout_key; end
  def unescape(str); end
  def verify_callback; end
  def verify_callback=(callback); end
  def verify_depth; end
  def verify_depth=(verify_depth); end
  def verify_mode; end
  def verify_mode=(verify_mode); end
end
class Net::HTTP::Persistent::Error < StandardError
end
